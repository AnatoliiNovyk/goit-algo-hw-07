# goit-algo-hw-07

# Домашнє завдання до теми “Дерева та балансування”

## Підготовчий етап: Реалізація Двійкового Дерева Пошуку (BST)
Для виконання перших трьох завдань, нам потрібна базова реалізація двійкового дерева пошуку (BST).  Я створив простий клас `Node` для представлення вузла та функцію `insert` для побудови дерева, спираючись на матеріали курсу.

```python
# Клас, що представляє окремий вузол у Двійковому Дереві Пошуку (BST)
class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

# Функція для вставки нового вузла з заданим ключем у BST
def insert(root, key):
    # Якщо дерево порожнє, повертаємо новий вузол
    if root is None:
        return Node(key)
    else:
        # Інакше, рекурсивно спускаємося по дереву
        if key < root.val:
            root.left = insert(root.left, key)
        else:
            root.right = insert(root.right, key)
    return root

# Створення тестового дерева для завдань 1, 2, 3
root = None
keys = [20, 8, 22, 4, 12, 10, 14, 25, 30]
for key in keys:
    root = insert(root, key)
```

------------

## Завдання 1: Пошук найбільшого значення в дереві
**Опис:** Написати алгоритм (функцію), який знаходить найбільше значення у двійковому дереві пошуку. 

### Рішення:
Згідно з властивостями двійкового дерева пошуку, найбільший елемент завжди знаходиться у крайньому правому вузлі.  Тому ми починаємо з кореня і рухаємось вправо, доки не досягнемо останнього вузла.

```python
def find_max(root):
    """
    Функція для знаходження найбільшого значення в BST.
    Рухається до крайнього правого вузла.
    """
    current = root
    # Цикл для переходу до крайнього правого нащадка
    while(current.right is not None):
        current = current.right
    return current.val
```

### Тестування Завдання 1:

```python
# Виклик функції та вивід результату
max_value = find_max(root)
print(f"Найбільше значення в дереві: {max_value}")

# Очікуваний результат: Найбільше значення в дереві: 30
```
### Виведення:

`Найбільше значення в дереві: 30`

**Результат:** Код виконується, і функція успішно знаходить найбільше значення в дереві.

------------

## Завдання 2: Пошук найменшого значення в дереві
**Опис:** Написати алгоритм (функцію), який знаходить найменше значення у двійковому дереві пошуку. 

### Рішення:
Аналогічно до пошуку максимуму, найменший елемент у BST завжди є крайнім лівим вузлом.  Алгоритм починається з кореня і рухається вліво до кінця.

```python
def find_min(root):
    """
    Функція для знаходження найменшого значення в BST.
    Рухається до крайнього лівого вузла.
    """
    current = root
    # Цикл для переходу до крайнього лівого нащадка
    while(current.left is not None):
        current = current.left
    return current.val
```

### Тестування Завдання 2:

```python
# Виклик функції та вивід результату
min_value = find_min(root)
print(f"Найменше значення в дереві: {min_value}")

# Очікуваний результат: Найменше значення в дереві: 4
```

### Виведення:

`Найменше значення в дереві: 4`

**Результат:** Код виконується, і функція успішно знаходить найменше значення в дереві.

------------

## Завдання 3: Пошук суми всіх значень у дереві
**Опис:** Написати алгоритм (функцію), який знаходить суму всіх значень у двійковому дереві пошуку. 

### Рішення:
Для знаходження суми ми використаємо рекурсивний підхід. Сума всього дерева дорівнює значенню поточного вузла плюс суми значень його лівого та правого піддерев.

```python
def sum_all_values(root):
    """
    Функція для знаходження суми всіх значень у дереві.
    Використовує рекурсивний обхід.
    """
    if root is None:
        return 0
    # Рекурсивно додаємо значення поточного вузла, лівого та правого піддерев
    return root.val + sum_all_values(root.left) + sum_all_values(root.right)
```

### Тестування Завдання 3:

```python
# Виклик функції та вивід результату
total_sum = sum_all_values(root)
print(f"Сума всіх значень у дереві: {total_sum}")

# Очікуваний результат: Сума всіх значень у дереві: 145 (20+8+22+4+12+10+14+25+30)
```

### Виведення:

`Сума всіх значень у дереві: 145`

**Результат:** Код виконується, і функція успішно знаходить суму всіх значень у дереві.

------------

## Завдання 4 (необов'язкове): Система коментарів
**Опис:** Реалізувати ієрархічну структуру даних для системи коментарів з можливістю додавання, видалення та відображення відповідей. 

### Рішення:
Я реалізував клас `Comment`, який відповідає всім вимогам: зберігає текст, автора, список відповідей та статус видалення.  Метод `display` рекурсивно виводить всю ієрархію з відповідними відступами.

```python
class Comment:
    def __init__(self, text, author):
        self.text = text
        self.author = author
        self.replies = []
        self.is_deleted = False

    def add_reply(self, reply):
        """Додає нову відповідь до коментаря."""
        # Перевірка, що відповідь є екземпляром класу Comment
        if isinstance(reply, Comment):
            self.replies.append(reply)
        else:
            print("Помилка: відповідь має бути об'єктом класу Comment.")

    def remove_reply(self):
        """
        "Видаляє" коментар, змінюючи його текст та встановлюючи прапорець.
        Фактично, коментар залишається в структурі, щоб зберегти відповіді на нього.
        """
        self.text = "Цей коментар було видалено."
        self.is_deleted = True
        self.author = "" # Опціонально, можна приховати автора

    def display(self, level=0):
        """Рекурсивно виводить коментар та всі його відповіді."""
        prefix = "    " * level
        if self.is_deleted:
            print(f"{prefix}{self.text}")
        else:
            print(f"{prefix}{self.author}: {self.text}")
        
        for reply in self.replies:
            reply.display(level + 1)
```

### Тестування Завдання 4:
**Відтворимо приклад, наведений в описі завдання.**

```python
# Створення коментарів
root_comment = Comment("Яка чудова книга!", "Бодя")
reply1 = Comment("Книга повне розчарування :(", "Андрій")
reply2 = Comment("Що в ній чудового?", "Марина")

# Додавання відповідей до головного коментаря
root_comment.add_reply(reply1)
root_comment.add_reply(reply2)

# Створення відповіді на відповідь
reply1_1 = Comment("Не книжка, а перевели купу паперу ні нащо...", "Сергій")
reply1.add_reply(reply1_1)

# Створення ще одного рівня вкладеності
reply2_1 = Comment("Теж не зрозуміла захоплення.", "Олена")
reply2.add_reply(reply2_1)

print("--- Початкова структура коментарів ---")
root_comment.display()

# "Видалення" коментаря Андрія
reply1.remove_reply()

print("\n--- Структура після видалення коментаря ---")
root_comment.display()
```

### Виведення:

```
--- Початкова структура коментарів ---
Бодя: Яка чудова книга!
    Андрій: Книга повне розчарування :(
        Сергій: Не книжка, а перевели купу паперу ні нащо...
    Марина: Що в ній чудового?
        Олена: Теж не зрозуміла захоплення.

--- Структура після видалення коментаря ---
Бодя: Яка чудова книга!
    Цей коментар було видалено.
        Сергій: Не книжка, а перевели купу паперу ні нащо...
    Марина: Що в ній чудового?
        Олена: Теж не зрозуміла захоплення.
```

**Результат:** Код виконується, і структура коментарів працює та відображається згідно з вимогами.

------------